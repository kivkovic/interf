<html>
<head>
  <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700&amp;subset=latin-ext" rel="stylesheet">

  <style type="text/css">
    body {
      margin: 0;
      padding: 0;
    }

    .terminal-input:focus {
      outline: none;
    }

    .terminal {
      font-family: 'Ubuntu Mono', monospace;
      color: #eee;
      background-color: #2a2a2a;
      font-size: 14px;
      overflow: auto;
    }

    .terminal .username .user {
      color: #6e6;
    }

    .terminal .username .at {
      color: #ee6;
    }

    .terminal .username .host {
      color: #be6;
    }

    .terminal .username .pwd {
      color: #eea;
    }

    .stderr,
    .terminal .username .sudo {
      color: #ebb;
    }

    .stdout {
      color: #efd;
    }

    .terminal a:link, .terminal a:visited, .terminal a:active {
      color: #ded;
      text-decoration: none;
      border-bottom: 1px dashed #444;
    }

    .terminal a:link[data-isdir="true"], .terminal a:visited[data-isdir="true"], .terminal a:active[data-isdir="true"]{
      color: #eea;
    }

    #terminal-autocomplete {
      position: absolute;
      display: none;
      font-family: 'Ubuntu Mono', monospace;
      color: #eee;
      background-color: #333;
      overflow: hidden;
    }
  </style>

  <script type="text/javascript">

  let user = {};

  function init() {
    return new Promise((resolve, reject) => {
      fetch('http://192.168.5.14:1337/stats')
        .then(response => response.json().then(json => {
          user.name = json.out.userInfo.username;
          user.host = json.out.hostname;
          resolve();
        }))
        .catch(error => reject(error));
    });
  }

  function initConsole(terminal, autocomplete) {
    terminal.classList.add('terminal');

    const username = document.createElement('span');
    username.className = 'username';
    username.innerHTML = `<span class="user">${user.name}</span><span class="at">@</span><span class="host">${user.host}</span>:<span class="pwd">~</span> <span class="mode">$</span>&nbsp;`;
    terminal.appendChild(username);

    const input = document.createElement('span');
    input.className = 'input';
    input.className = 'terminal-input';
    input.contentEditable = true;
    input.innerText = '';
    terminal.appendChild(input);

    setEndOfContenteditable(input);

    autocomplete.onkeydown = event => {
      if (event.key == 'Enter' || event.key == ' ' || event.key == 'Escape' || event.key == 'Tab' || event.key == 'Backspace') {
        if (event.key == 'Backspace') {
          input.innerText = input.innerText.slice(0, -1);
        } else if (event.key != 'Escape') {
          if (input.innerText.match(/(\u00a0| )$/)) {
            input.innerText += autocomplete.value;
          } else {
            input.innerText = autocomplete.value;
          }
        }
        autocomplete.style.display = 'none';
        input.focus();
        setEndOfContenteditable(input);
        event.preventDefault();
        return false;
      }
    };

    let start = terminal.selectionStart;
    let disabled = false;
    let historycounter = 0;
    let currentPwd = '~';
    let waitingForPassword = false;
    let checkForSudo = null;
    let command = null;
    const executedlines = [];

    function createNewLine(type = 'normal') {
      terminal.appendChild(document.createElement('br'));
      const clone = username.cloneNode(true);

      if (type != 'password') {
        clone.innerHTML = clone.innerHTML.replace(/<span class="pwd">[^<]+<\/span>/, `<span class="pwd">${currentPwd}</span>`);

      } else {
        const last = getLastChild(terminal);
        const parent = last.parentNode;
        parent.replaceChild(document.createTextNode(input.innerText), last);
        parent.appendChild(last);
        clone.innerHTML = `<span class="sudo">sudo</span> password for ${user.name}:&nbsp;`;
        waitingForPassword = true
      }

      if (type == 'password') ;
      terminal.appendChild(clone);
      terminal.appendChild(input);
      input.innerText = '';
      setEndOfContenteditable(input);
      terminal.scrollTop = terminal.scrollHeight;

      return { clone, input };
    }

    function appendResponse(out, error, postprocess, cmd) {
      terminal.replaceChild(input.cloneNode(true), input);

      const response = document.createElement('div');
      response.style.cssText = 'white-space: pre;';
      if (postprocess) {
        response.appendChild(postprocess(out, cmd));
      } else if (error) {
        response.className = 'stderr';
        response.innerText = error;
      } else {
        response.className = 'stdout';
        response.innerText = out;
      }
      terminal.appendChild(response);

      createNewLine();
    }

    function open(location) {
      fetch('http://192.168.5.14:1337/typeof?path=' + encodeURIComponent(location.replace(/\/*$/, '')))
        .then(response => response.json().then(json => {
          const matches = json.out.response.match(/^([^:]+): ([^/]+\/[^/]+);/);
          handleFileOpen(json.out.pwd + '/' + matches[1], matches[2]);

          //appendResponse(json.out.files, null, formatFileList, 'ls -lhFa'); // TODO restore this line if dir
        }))
        .catch(error => console.error(error));
    }

    function formatFileList(text, cmd = '') {
      let lines = text.split('\n');
      const command = cmd.match(/^\s*ls(?: ((?:\s*--[a-z\-]+(?:="[^"]*"|='[^']*')?)*)\s*(?:-([A-Za-z]*))?((?:\s*--[a-z\-]+(?:="[^"]*"|='[^']*')?)*))?(\s+[^-].*)?\s*$/) || '';

      const long = (command[1] || '') + ' ' + (command[3] || '');
      if ((!command[2] || command[2].indexOf('x') == -1) && !long.match(/\b--(help|version)/)) {

        if (!command[2] || !command[2].match(/[lR]/)) {
          lines = lines.map(line => {
            const entry = document.createElement('a');
            entry.href = '#';
            entry.className = 'file-link';
            entry.dataset.filefolder = 'true';
            entry.dataset.isdir = '?';
            entry.innerText = line;
            entry.onclick = open.bind(this, line);
            return entry;
          });

        } else if (command[2].match(/R/)) {
          // recursive

        } else if (command[2].match(/l/)) {
          lines = lines.map((line, i) => {
            if (!i) return line;

            const info = line.replace(/(?<=.*?[0-9]{2}:[0-9]{2} ).*$/, ''),
              filename = line.replace(/.*?[0-9]{2}:[0-9]{2} /, ''),
              isdir = !!line.match(/^d/);

            const entry = document.createElement('a');
            entry.href = '#';
            entry.className = 'file-link';
            entry.dataset.filefolder = 'true';
            entry.dataset.isdir = isdir;
            entry.innerText = filename;
            entry.onclick = open.bind(this, filename);

            const wrapper = document.createElement('span');
            wrapper.appendChild(document.createTextNode(info));
            wrapper.appendChild(entry);

            return wrapper;
          });
        }
      }

      const container = document.createElement('div');
      lines
        .map(line => typeof line == 'string' ? document.createTextNode(line) : line)
        .map(line => (container.appendChild(line), container.appendChild(document.createElement('br'))));
      return container;
    }

    terminal.onfocus = function () {
      input.focus();
    }

    terminal.onkeydown = function (event) {
      if (disabled) {
        event.preventDefault();
        return false;
      }

      const text = input.innerText.replace(/\u00a0/g, ' ');

      if (event.key == 'Enter') {
        if (text.length) {
          executedlines.push(text);
          historycounter = executedlines.length;
          disabled = true;

          checkForSudo = new Promise((resolve, reject) => {

            if (waitingForPassword) {
              waitingForPassword = false;
              resolve(encodeURIComponent(command) + '&password=' + encodeURIComponent(text));
              command = null;

            } else if (text.match(/^\s*sudo\s+/)) {
              command = text;
              disabled = false;
              createNewLine('password');

            } else if (text.match(/^\s*clear\s*$/)) {
              const { clone, input } = createNewLine();
              Array.from(terminal.children).map(child => {
                if (child != clone && child != input) terminal.removeChild(child);
              });
              disabled = false;

            } else {
              resolve(encodeURIComponent(text));
            }
          }).then(command => fetch('http://192.168.5.14:1337/bash?cmd=' + command)
            .then(response => response.json().then(json => {
              if (json.pwd) {
                currentPwd = json.pwd;
              }
              // post-process special cases
              if (text.match(/^\s*ls\b/)) { // /^ls(( -[^x]+| [^-].+)\b|$)/
                appendResponse(json.out, json.error, formatFileList, text); // TODO different handling for ok and error
              } else {
                appendResponse(json.out, json.error); // TODO different handling for ok and error
              }
              disabled = false;
              terminal.scrollTop = terminal.scrollHeight;
            }))
            .catch(error => {
              console.error(error);
              appendResponse(null, error.out);
              disabled = false;
              terminal.scrollTop = terminal.scrollHeight;
            }));
        } else if (waitingForPassword) {
          checkForSudo.resolve(text);
        } else {
          createNewLine();
        }
        event.preventDefault();
        return false;

      } else if (event.key == 'ArrowUp') {
        if (executedlines.length) {
          historycounter = historycounter > 0 ? --historycounter : executedlines.length - 1;
          text = executedlines[historycounter];
          setEndOfContenteditable(input);
        }
        event.preventDefault();
        return false;

      } else if (event.key == 'ArrowDown') {
        if (executedlines.length) {
          historycounter = (historycounter + 1) % executedlines.length;
          text = executedlines[historycounter];
          setEndOfContenteditable(input);
        }
        event.preventDefault();
        return false;

      } else if (event.key == 'Tab') {

        fetch('http://192.168.5.14:1337/bash?autocomplete=' + encodeURIComponent(text))
          .then(response => response.json())
          .then(json => {
            if (!json.out.response.length) return;

            autocomplete.innerHTML = '';
            json.out.response.map(entry => {
              const option = document.createElement('option');
              option.value = option.innerText = entry;
              autocomplete.appendChild(option);
            });

            autocomplete.size = Math.min(8, json.out.response.length);
            autocomplete.style.display = 'block';
            autocomplete.style.top = (input.offsetTop + input.offsetHeight + 2) + 'px';
            autocomplete.style.left = input.offsetLeft + 'px';
            autocomplete.selectedIndex = 0;
            autocomplete.focus();
            //autocomplete.
          })
          .catch(error => console.error(error));
          event.preventDefault();
          return false;

      } else if (event.key == 'r' && event.ctrlKey) {
        // TODO implement reverse search
        console.log(event.key, event)
        event.stopPropagation();
        event.preventDefault();
        return false;
      }
    }
  }

  function handleFileOpen(file, type) {

    const display = document.querySelector('#display'); // TODO extract
    const editor = document.querySelector('#text-editor'); // TODO extract
    display.parentNode.style.display = 'none';
    editor.style.display = 'none';

    const embed = document.createElement('embed');
    embed.type = type;
    embed.src = 'http://192.168.5.14:1337/' + file;

    if (type == 'text/plain') {
      embed.style.minWidth = '100%';
      embed.style.minHeight = '50vh';
      editor.innerHTML = '';
      editor.appendChild(embed);
      editor.style.display = 'block';

    } else {

      if (type.match(/^video/)) {
        embed.style.width = '100%';
        embed.style.height = '100%';
      } else {
        embed.style.minWidth = '100%';
        embed.style.minHeight = '50vh';
      }

      display.innerHTML = '';
      display.appendChild(embed);
      display.parentNode.style.display = 'block';
    }
  }

  function getLastChild(element) {
    let lastChild = element.lastChild;
    while (lastChild && lastChild.nodeType != 1) {
      if (lastChild.previousSibling) {
        lastChild = lastChild.previousSibling;
      } else {
        break;
      }
    }
    return lastChild;
  }

  function canContainText(node) {
    if (node.nodeType == 1) {
      return !['BR', 'IMG', 'INPUT', 'LABEL', 'DIV', 'SPAN', 'STRONG'].indexOf(node.nodeName) != -1;
    }
    return false;
  }

  function getEndOfContenteditable(element) {
    for (let child = getLastChild(element); child && canContainText(child); element = getLastChild(element)) {
      child = getLastChild(element);
    }
    return element;
  }

  function setEndOfContenteditable(element) { // https://stackoverflow.com/a/19588665
    const range = document.createRange();
    range.selectNodeContents(getEndOfContenteditable(element));
    range.collapse(false);
    const selection = window.getSelection();
    selection.removeAllRanges();
    selection.addRange(range);
  }

  window.addEventListener('DOMContentLoaded', (event) => {
    init()
      .then(() => {
        initConsole(document.getElementById('terminal'), document.getElementById('terminal-autocomplete'));
        //initNavigator(document.getElementById('navigator'));
      })
      .catch(error => console.error(error));
  });
  </script>
</head>
<body>
  <div id="terminal" tabindex="0" style="width: calc(100% - 20px); height: calc(50vh - 25px); max-height: calc(50vh - 25px); margin: 10px;">
  </div>
  <select multiple id="terminal-autocomplete"></select>
  <div style="display: none; width: calc(100% - 20px); height: calc(50vh - 25px); max-height: calc(50vh - 25px); margin: 10px; overflow-x: hidden; overflow-y: scroll;">
    <div id="display" style="width: 100%;"></div>
  </div>
  <div id="text-editor" style="display: none; width: calc(100% - 20px); height: calc(50vh - 25px); max-height: calc(50vh - 25px); margin: 10px;"></div>
</body>
</html>