<html>
<head>
  <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700&amp;subset=latin-ext" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:300,400,500&amp;subset=latin-ext" rel="stylesheet">
  <link href="assets/prism.css" rel="stylesheet" />
  <style type="text/css">
    body {
      margin: 0;
      padding: 0;
      background: #333;
      box-sizing: border-box;
    }

    .terminal-input {
      font-family: 'Roboto Mono', monospace;
      font-weight: 300;
      font-size: 12px;
      color: #eee;
      border: 1px solid transparent;
      background-color: #2a2a2a;
    }

    .terminal-input:focus {
      outline: none;
    }

    .terminal-input.password {
      -webkit-text-security: disc;
      position: relative;
      top: 1px;
    }

    .terminal {
      font-family: 'Roboto Mono', monospace;
      font-weight: 300;
      font-size: 12px;
      color: #eee;
      background-color: #2a2a2a;
      overflow-y: scroll;
      overflow-x: auto;
      padding: 5px;
    }

    .terminal::-webkit-scrollbar {
        width: 10px;
        height: 10px;
        background: #222;
    }

    .terminal::-webkit-scrollbar-thumb {
      background: #444;
    }

    .stderr,
    .terminal .sudo {
      color: #f87;
      font-weight: 400;
    }

    .stdout {
      color: #efd;
    }

    .stdout:focus {
      outline: none;
    }

    .terminal a:link, .terminal a:visited, .terminal a:active {
      color: #ded;
      text-decoration: none;
      border-bottom: 1px dashed #444;
    }

    .terminal a:link[data-isdir="true"], .terminal a:visited[data-isdir="true"], .terminal a:active[data-isdir="true"]{
      color: #eea;
    }

    #terminal-autocomplete {
      position: absolute;
      display: none;
      font-family: 'Roboto Mono', monospace;
      font-weight: 300;
      font-size: 12px;
      color: #eee;
      background-color: #333;
      overflow: hidden;
    }
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js"></script>

  <script type="text/javascript">

  let user = {};

  const server = 'http://192.168.5.14:1337/';

  function initConsole(terminal, autocomplete) {
    terminal.classList.add('terminal');

    const location = document.createElement('span');
    terminal.appendChild(location);
    let locationText = '';

    const input = document.createElement('input');
    input.className = 'input';
    input.className = 'terminal-input';
    input.value = '';
    terminal.appendChild(input);
    input.focus();

    let start = terminal.selectionStart;
    let disabled = false;
    let historycounter = 0;
    let currentPwd = '~';
    let waitingForCommand = false;
    let waitingForPassword = false;
    let waitingForCtrlEvent = false;
    let waitingForAutocomplete = false;
    let command = null;
    let lastResponse = null;
    let lineBuffer = [];
    const executedlines = [];
    const socket = io(server);

    socket.on('connected', data => {
      console.log('connected to socket.io on ' + server);
      socket.emit('bash', 'hello\n');
    });

    socket.on('console.out', data => {

      clearTimeout(lastResponse);
      lastResponse = setTimeout(() => {
        console.log('data from server', lineBuffer);

        if (waitingForAutocomplete || waitingForCtrlEvent) {

          let lines = [];
          autocomplete.innerHTML = '';

          if (waitingForAutocomplete) {
            lines = lineBuffer[1].split(/\s+/).filter(line => line);

          } else if (waitingForCtrlEvent) {
            if (lineBuffer.join('').match(/\(reverse-i-search\)/)) {
              lineBuffer = [];
              return;
            }
            lines = lineBuffer.map(line => line.replace(/^.+?':\s*/, '').replace(/\x1b\[C\x1B\[.*$/, ''));
          }

          lines.map(entry => {
            const option = document.createElement('option');
            option.value = option.innerText = entry;
            autocomplete.appendChild(option);
          });

          waitingForAutocomplete = false;
          autocomplete.size = Math.min(8, lines.length);
          autocomplete.style.display = 'block';
          autocomplete.style.top = (input.offsetTop + input.offsetHeight + 2) + 'px';
          autocomplete.style.left = input.offsetLeft + 'px';
          autocomplete.selectedIndex = 0;
          autocomplete.focus();

        } else {

          if (!lineBuffer.length) {
            debugger; // should be unreachable

          } else if ((lineBuffer[0] + lineBuffer[1]).match(/(\[sudo\] password for|Sorry, try again)/i)) {
            waitingForPassword = true;
            createNewLine('password');

          } else {

            const response = lineBuffer
              .join('\r\n').split('\r\n') // realigns line endings, because the way bash output is chunked is random
              .filter((line, i, lines) => {
                if (i == lines.length - 1) {
                  locationText = bashColors(line.replace(/^.+?\x07/, ''));
                }
                // 1) skip empty lines and \uffe3 (response from ctrl commands)
                // 2) if a command was pushed, it's echoed back in the first line of the response, so skip it (could be used to replace current input)
                // 3) last line is input line prefix
                return line.length && line != '\uffe3' && (i != 0 || !waitingForCommand) && i != lines.length - 1;
              });

            appendResponse(response.join('\n'));
          }

          waitingForCommand = false;
        }

        lineBuffer = [];
        disabled = false;
      }, 600);

      lineBuffer.push(data);
    });

    function createNewLine(type = 'normal') {
      terminal.appendChild(document.createElement('br'));
      const clone = location.cloneNode(true);

      if (type != 'password') {
        clone.innerHTML = locationText;
        input.classList.remove('password');

      } else {
        const last = getLastChild(terminal);
        const parent = last.parentNode;
        parent.replaceChild(document.createTextNode(input.value), last);
        parent.appendChild(last);
        clone.innerHTML = `<span class="sudo">Password:</span>&nbsp;`;
        waitingForPassword = true;
        input.value = '';
        input.classList.add('password');
      }

      terminal.appendChild(clone);
      terminal.appendChild(input);
      input.style.width = `calc(100% - ${Math.max(input.offsetLeft, 200)}px)`;
      input.focus();
      terminal.scrollTop = terminal.scrollHeight;
    }

    function appendResponse(string) {
      const clone = input.cloneNode(true);
      clone.readOnly = 'readonly';
      terminal.replaceChild(clone, input);
      input.value = '';

      const response = document.createElement('div');
      response.style.cssText = 'white-space: pre;';
      response.className = 'stdout';
      response.tabIndex = '0';
      response.innerHTML = bashColors(string);
      terminal.appendChild(response);

      createNewLine();
    }

    function executeInput() {
      executedlines.push(input.value);
      historycounter = executedlines.length;

      const command = input.value + '\n';
      console.log('sending command', command);
      socket.emit('bash', command);

      disabled = true;
      waitingForCommand = true;
      waitingForPassword = false;
    }

    terminal.onfocus = function () {
      input.focus();
    }

    terminal.onkeydown = function (event) {

      if (event.ctrlKey && event.key != 'Control') { // ctrl + letter combos
        event.stopPropagation();
        event.preventDefault();

        socket.emit('bash', String.fromCharCode(event.key.charCodeAt(0) - 96));
        if (event.key == 'c') {
          waitingForCtrlEvent = false;
        } else if (event.key == 'r') {
          waitingForCtrlEvent = true;
          input.onkeydown = event => {
            if (event.key == 'Enter') debugger;
            const key = event.key.length == 1 ? event.key : String.fromCharCode(event.keyCode);
            socket.emit('bash', key);
          }
        }

        return false;
      }

      if (disabled) {
        event.preventDefault();
        return false;
      }

      const text = input.value.replace(/\u00a0/g, ' ');

      if (event.key == 'Enter') {
        if (text.length) {
          executeInput();
        } else {
          createNewLine();
        }
        event.preventDefault();
        return false;

      } else if (event.key == 'ArrowUp') {

        if (executedlines.length) {
          historycounter = historycounter > 0 ? --historycounter : executedlines.length - 1;
          input.value = executedlines[historycounter];
          input.focus();
        }
        event.preventDefault();
        return false;

      } else if (event.key == 'ArrowDown') {
        if (executedlines.length) {
          historycounter = (historycounter + 1) % executedlines.length;
          input.value = executedlines[historycounter];
          input.focus();
        }
        event.preventDefault();
        return false;

      } else if (event.key == 'Tab') {
        waitingForAutocomplete = true;
        socket.emit('bash', `echo ${text.trim()}$'\\t'$'\\t' | bash -i 2>&1 | head -n -4 | tail -n +2\n`);
        event.preventDefault();
        return false;

      }
    }

    autocomplete.onkeydown = event => {
      if (event.key == 'Enter' || event.key == ' ' || event.key == 'Escape' || event.key == 'Tab' || event.key == 'Backspace') {
        if (event.key == 'Backspace') {
          input.value = input.value.slice(0, -1);
        } else if (event.key != 'Escape') {
          if (input.value.match(/(\u00a0| )$/)) {
            input.value += autocomplete.value;
          } else {
            input.value = autocomplete.value;
          }
        }

        autocomplete.style.display = 'none';
        input.focus();
        event.preventDefault();
        return false;
      }
    };

  }

  function handleFileOpen(file, type) {

    const display = document.querySelector('#display'); // TODO extract
    const editor = document.querySelector('#text-editor'); // TODO extract
    display.parentNode.style.display = 'none';
    editor.style.display = 'none';

    const embed = document.createElement('embed');
    embed.type = type;
    embed.src = 'http://192.168.5.14:1337/' + file;

    if (type.match(/^text/)) {
      //fetch('http://192.168.5.14:1337/' + file)
        //.then(contents => editor.innerText = contents);

      //console.log(embed, embed.getSVGDocument())
//debugger
      embed.style.minWidth = '100%';
      embed.style.minHeight = '50vh';
      editor.innerHTML = '';
      editor.appendChild(embed);
      editor.style.display = 'block';

    } else {
      //const embed = document.createElement('embed');
      //embed.type = type;
      //embed.src = 'http://192.168.5.14:1337/' + file;

      if (type.match(/^video/)) {
        embed.style.width = '100%';
        embed.style.height = '100%';
      } else {
        embed.style.minWidth = '100%';
        embed.style.minHeight = '50vh';
      }

      display.innerHTML = '';
      display.appendChild(embed);
      display.parentNode.style.display = 'block';
    }
  }

  function getLastChild(element) {
    let lastChild = element.lastChild;
    while (lastChild && lastChild.nodeType != 1) {
      if (lastChild.previousSibling) {
        lastChild = lastChild.previousSibling;
      } else {
        break;
      }
    }
    return lastChild;
  }

  function canContainText(node) {
    if (node.nodeType == 1) {
      return !['BR', 'IMG', 'INPUT', 'LABEL', 'DIV', 'SPAN', 'STRONG'].indexOf(node.nodeName) != -1;
    }
    return false;
  }

  function bashColors(string) {
    return (string
      .replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') // html escape
      .replace(/\x1B\[([0-9;]+)m/g, (matches, font) => {
        if (font == '0') return '</span>';

        let style = '';
        if (font.match(/\b0?0?1\b/)) style += 'font-weight: 500;';
        if (font.match(/\b0?30\b/)) style += 'color: black;';
        if (font.match(/\b0?31\b/)) style += 'color: crimson;';
        if (font.match(/\b0?32\b/)) style += 'color: green;';
        if (font.match(/\b0?33\b/)) style += 'color: gold;';
        if (font.match(/\b0?34\b/)) style += 'color: cornflowerblue;';
        if (font.match(/\b0?35\b/)) style += 'color: mediumorchid;';
        if (font.match(/\b0?36\b/)) style += 'color: darkcyan;';
        if (font.match(/\b0?37\b/)) style += 'color: lightgray;';
        if (font.match(/\b0?90\b/)) style += 'color: darkgray;';
        if (font.match(/\b0?91\b/)) style += 'color: red;';
        if (font.match(/\b0?92\b/)) style += 'color: lime;';
        if (font.match(/\b0?93\b/)) style += 'color: yellow;';
        if (font.match(/\b0?94\b/)) style += 'color: deepskyblue;';
        if (font.match(/\b0?95\b/)) style += 'color: magenta;';
        if (font.match(/\b0?96\b/)) style += 'color: cyan;';
        if (font.match(/\b0?97\b/)) style += 'color: white;';
        if (font.match(/\b0?40\b/)) style += 'background: black;';
        if (font.match(/\b0?41\b/)) style += 'background: crimson;';
        if (font.match(/\b0?42\b/)) style += 'background: green;';
        if (font.match(/\b0?43\b/)) style += 'background: gold;';
        if (font.match(/\b0?44\b/)) style += 'background: cornflowerblue;';
        if (font.match(/\b0?45\b/)) style += 'background: mediumorchid;';
        if (font.match(/\b0?46\b/)) style += 'background: darkcyan;';
        if (font.match(/\b0?47\b/)) style += 'background: lightgray;';
        if (font.match(/\b100\b/)) style += 'background: darkgray;';
        if (font.match(/\b101\b/)) style += 'background: red;';
        if (font.match(/\b102\b/)) style += 'background: lime;';
        if (font.match(/\b103\b/)) style += 'background: yellow;';
        if (font.match(/\b104\b/)) style += 'background: deepskyblue;';
        if (font.match(/\b105\b/)) style += 'background: magenta;';
        if (font.match(/\b106\b/)) style += 'background: cyan;';
        if (font.match(/\b107\b/)) style += 'background: white;';

        return `<span style="${style}">`;
      }));
  }

  window.addEventListener('DOMContentLoaded', (event) => {
    initConsole(document.getElementById('terminal'), document.getElementById('terminal-autocomplete'));
  });
  </script>
</head>
<body>
  <div id="terminal" tabindex="0" style="width: calc(100% - 30px); height: calc(50vh - 25px); max-height: calc(50vh - 25px); margin: 10px;">
  </div>
  <select multiple id="terminal-autocomplete"></select>
  <div style="display: none; width: calc(100% - 20px); height: calc(50vh - 25px); max-height: calc(50vh - 25px); margin: 10px; overflow-x: hidden; overflow-y: scroll;">
    <div id="display" style="width: 100%;"></div>
  </div>
  <div id="text-editor" style="display: none; width: calc(100% - 20px); height: calc(50vh - 25px); max-height: calc(50vh - 25px); margin: 10px;"></div>
</body>
</html>
