<html>
<head>
  <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700&amp;subset=latin-ext" rel="stylesheet">

  <style type="text/css">
    body {
      margin: 0;
      padding: 0;
    }

    .terminal-input:focus {
      outline: none;
    }

    .terminal-input.password {
      -webkit-text-security: disc;
      position: relative;
      top: 1px;
    }

    .terminal {
      font-family: 'Ubuntu Mono', monospace;
      color: #eee;
      background-color: #2a2a2a;
      font-size: 14px;
      overflow: auto;
    }

    .terminal .username .user {
      color: #6e6;
    }

    .terminal .username .at {
      color: #ee6;
    }

    .terminal .username .host {
      color: #be6;
    }

    .terminal .username .pwd {
      color: #eea;
    }

    .stderr,
    .terminal .username .sudo {
      color: #ebb;
    }

    .stdout {
      color: #efd;
    }

    .terminal a:link, .terminal a:visited, .terminal a:active {
      color: #ded;
      text-decoration: none;
      border-bottom: 1px dashed #444;
    }

    .terminal a:link[data-isdir="true"], .terminal a:visited[data-isdir="true"], .terminal a:active[data-isdir="true"]{
      color: #eea;
    }

    #terminal-autocomplete {
      position: absolute;
      display: none;
      font-family: 'Ubuntu Mono', monospace;
      color: #eee;
      background-color: #333;
      overflow: hidden;
    }
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js"></script>

  <script type="text/javascript">

  let user = {};

  const server = 'http://192.168.5.14:1337/';

  function init() {
    return new Promise((resolve, reject) => {
      fetch(server + 'stats')
        .then(response => response.json().then(json => {
          user.name = json.out.userInfo.username;
          user.host = json.out.hostname;
          resolve();
        }))
        .catch(error => reject(error));
    });
  }

  function initConsole(terminal, autocomplete) {
    terminal.classList.add('terminal');

    const username = document.createElement('span');
    username.className = 'username';
    username.innerHTML = `<span class="user">${user.name}</span><span class="at">@</span><span class="host">${user.host}</span>:<span class="pwd">~</span> <span class="mode">$</span>&nbsp;`;
    terminal.appendChild(username);

    const input = document.createElement('span');
    input.className = 'input';
    input.className = 'terminal-input';
    input.contentEditable = true;
    input.innerText = '';
    terminal.appendChild(input);

    setEndOfContenteditable(input);

    let start = terminal.selectionStart;
    let disabled = false;
    let historycounter = 0;
    let currentPwd = '~';
    let waitingForCommand = false;
    let waitingForPassword = false;
    let waitingForCtrlEvent = false;
    let waitingForAutocomplete = false;
    let command = null;
    let lastResponse = null;
    let lineBuffer = [];
    const executedlines = [];
    const socket = io(server);

    socket.on('connected', data => console.log('connected to socket.io on ' + server));

    socket.on('console.out', data => {

      clearTimeout(lastResponse);
      lastResponse = setTimeout(() => {
        console.log('data from server', lineBuffer);

        if (waitingForCommand) {
          waitingForCommand = false;

          if (!lineBuffer.length) {
            debugger; // should be unreachable

          } else if ((lineBuffer[0] + lineBuffer[1]).match(/(\[sudo\] password for|Sorry, try again)/i)) {
            waitingForPassword = true;
            createNewLine('password');

          } else {

            const response = lineBuffer
              .filter((line, i) => {
                if (i == 0 || i == lineBuffer.length - 1) return false;
                if (i >= lineBuffer.length - 2) {
                  const pwd = line.match(/\s*___PWD=(.+)\s*\n/);
                  if (pwd) {
                    currentPwd = pwd[1];
                    // TODO check return code
                    return false;
                  }
                }
                return true;
              })
              .join('');
            appendResponse(response);
          }

        } else if (waitingForAutocomplete) {
          waitingForAutocomplete = false;

          autocomplete.innerHTML = '';
          const lines = lineBuffer[1].split(/\s+/).filter(line => line);
          lines.map(entry => {
            const option = document.createElement('option');
            option.value = option.innerText = entry;
            autocomplete.appendChild(option);
          });

          autocomplete.size = Math.min(8, lines.length);
          autocomplete.style.display = 'block';
          autocomplete.style.top = (input.offsetTop + input.offsetHeight + 2) + 'px';
          autocomplete.style.left = input.offsetLeft + 'px';
          autocomplete.selectedIndex = 0;
          autocomplete.focus();

        } else if (waitingForCtrlEvent) {
          // TODO
        }

        lineBuffer = [];
        disabled = false;
      }, 400);

      lineBuffer.push(data);
    });

    function createNewLine(type = 'normal') {
      terminal.appendChild(document.createElement('br'));
      const clone = username.cloneNode(true);

      if (type != 'password') {
        clone.innerHTML = clone.innerHTML.replace(/<span class="pwd">[^<]+<\/span>/, `<span class="pwd">${currentPwd}</span>`);
        input.classList.remove('password');

      } else {
        const last = getLastChild(terminal);
        const parent = last.parentNode;
        parent.replaceChild(document.createTextNode(input.innerText), last);
        parent.appendChild(last);
        clone.innerHTML = `<span class="sudo">sudo</span> password for ${user.name}:&nbsp;`;
        waitingForPassword = true
        input.classList.add('password');
      }

      terminal.appendChild(clone);
      terminal.appendChild(input);
      input.innerText = '';
      setEndOfContenteditable(input);
      terminal.scrollTop = terminal.scrollHeight;

      return { clone, input };
    }

    function appendResponse(string) {
      terminal.replaceChild(input.cloneNode(true), input);

      const response = document.createElement('div');
      response.style.cssText = 'white-space: pre;';
      response.className = 'stdout';
      response.innerHTML = bashColors(string);
      terminal.appendChild(response);

      createNewLine();
    }

    function bashColors(string) {
      return (string
        .replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;') // html escape
        .replace(/\x1B\[([0-9;]+)m/g, (matches, font) => {
          if (font == '0') return '</span>';

          let style = '';
          if (font.match(/\b0?1\b/)) style += 'font-weight: bold;';
          if (font.match(/\b30\b/)) style += 'color: black;';
          if (font.match(/\b31\b/)) style += 'color: crimson;';
          if (font.match(/\b32\b/)) style += 'color: green;';
          if (font.match(/\b33\b/)) style += 'color: gold;';
          if (font.match(/\b34\b/)) style += 'color: cornflowerblue;';
          if (font.match(/\b35\b/)) style += 'color: mediumorchid;';
          if (font.match(/\b36\b/)) style += 'color: darkcyan;';
          if (font.match(/\b37\b/)) style += 'color: lightgray;';
          if (font.match(/\b90\b/)) style += 'color: darkgray;';
          if (font.match(/\b91\b/)) style += 'color: red;';
          if (font.match(/\b92\b/)) style += 'color: lime;';
          if (font.match(/\b93\b/)) style += 'color: yellow;';
          if (font.match(/\b94\b/)) style += 'color: deepskyblue;';
          if (font.match(/\b95\b/)) style += 'color: magenta;';
          if (font.match(/\b96\b/)) style += 'color: cyan;';
          if (font.match(/\b97\b/)) style += 'color: white;';
          if (font.match(/\b40\b/)) style += 'background: black;';
          if (font.match(/\b41\b/)) style += 'background: crimson;';
          if (font.match(/\b42\b/)) style += 'background: green;';
          if (font.match(/\b43\b/)) style += 'background: gold;';
          if (font.match(/\b44\b/)) style += 'background: cornflowerblue;';
          if (font.match(/\b45\b/)) style += 'background: mediumorchid;';
          if (font.match(/\b46\b/)) style += 'background: darkcyan;';
          if (font.match(/\b47\b/)) style += 'background: lightgray;';
          if (font.match(/\b100\b/)) style += 'background: darkgray;';
          if (font.match(/\b101\b/)) style += 'background: red;';
          if (font.match(/\b102\b/)) style += 'background: lime;';
          if (font.match(/\b103\b/)) style += 'background: yellow;';
          if (font.match(/\b104\b/)) style += 'background: deepskyblue;';
          if (font.match(/\b105\b/)) style += 'background: magenta;';
          if (font.match(/\b106\b/)) style += 'background: cyan;';
          if (font.match(/\b107\b/)) style += 'background: white;';

          return `<span style="${style}">`;
        }));
    }

    terminal.onfocus = function () {
      input.focus();
    }

    terminal.onkeydown = function (event) {

      if (event.ctrlKey) {
        if (event.key == 'c') socket.emit('bash', '\x03');
        if (event.key == 'd') socket.emit('bash', '\x04');
        if (event.key == 'r') socket.emit('bash', '\x12');
        // TODO implement reverse search
        //console.log(event.key, event)
        waitingForCtrlEvent = true;

        event.stopPropagation();
        event.preventDefault();
        return false;
      }

      if (disabled) {
        event.preventDefault();
        return false;
      }

      const text = input.innerText.replace(/\u00a0/g, ' ');

      if (event.key == 'Enter') {
        if (text.length) {
          executedlines.push(text);
          historycounter = executedlines.length;

          let command;
          if (waitingForPassword) {
            input.style.opacity = '0';
            input.classList.remove('password');
            command = input.innerText + '\n';
            input.innerHTML = '';
            input.style.opacity = '1';

          } else {
            command =  text.trim() + ' && echo ___PWD=$PWD && echo ___RETURNCODE=$?\n';
          }

          console.log('sending command', command);
          socket.emit('bash', command);

          disabled = true;
          waitingForCommand = true;
          waitingForPassword = false;

        } else {
          createNewLine();
        }
        event.preventDefault();
        return false;

      } else if (event.key == 'ArrowUp') {

        if (executedlines.length) {
          historycounter = historycounter > 0 ? --historycounter : executedlines.length - 1;
          input.innerText = executedlines[historycounter];
          setEndOfContenteditable(input);
        }
        event.preventDefault();
        return false;

      } else if (event.key == 'ArrowDown') {
        if (executedlines.length) {
          historycounter = (historycounter + 1) % executedlines.length;
          input.innerText = executedlines[historycounter];
          setEndOfContenteditable(input);
        }
        event.preventDefault();
        return false;

      } else if (event.key == 'Tab') {
        waitingForAutocomplete = true;
        socket.emit('bash', `echo ${text.trim()}$'\\t'$'\\t' | bash -i 2>&1 | head -n -4 | tail -n +2\n`);
        event.preventDefault();
        return false;

      }
    }

    autocomplete.onkeydown = event => {
      if (event.key == 'Enter' || event.key == ' ' || event.key == 'Escape' || event.key == 'Tab' || event.key == 'Backspace') {
        if (event.key == 'Backspace') {
          input.innerText = input.innerText.slice(0, -1);
        } else if (event.key != 'Escape') {
          if (input.innerText.match(/(\u00a0| )$/)) {
            input.innerText += autocomplete.value;
          } else {
            input.innerText = autocomplete.value;
          }
        }
        autocomplete.style.display = 'none';
        input.focus();
        setEndOfContenteditable(input);
        event.preventDefault();
        return false;
      }
    };

  }

  function handleFileOpen(file, type) {

    const display = document.querySelector('#display'); // TODO extract
    const editor = document.querySelector('#text-editor'); // TODO extract
    display.parentNode.style.display = 'none';
    editor.style.display = 'none';

    const embed = document.createElement('embed');
    embed.type = type;
    embed.src = 'http://192.168.5.14:1337/' + file;

    if (type.match(/^text/)) {
      //fetch('http://192.168.5.14:1337/' + file)
        //.then(contents => editor.innerText = contents);

      //console.log(embed, embed.getSVGDocument())
//debugger
      embed.style.minWidth = '100%';
      embed.style.minHeight = '50vh';
      editor.innerHTML = '';
      editor.appendChild(embed);
      editor.style.display = 'block';

    } else {
      //const embed = document.createElement('embed');
      //embed.type = type;
      //embed.src = 'http://192.168.5.14:1337/' + file;

      if (type.match(/^video/)) {
        embed.style.width = '100%';
        embed.style.height = '100%';
      } else {
        embed.style.minWidth = '100%';
        embed.style.minHeight = '50vh';
      }

      display.innerHTML = '';
      display.appendChild(embed);
      display.parentNode.style.display = 'block';
    }
  }

  function getLastChild(element) {
    let lastChild = element.lastChild;
    while (lastChild && lastChild.nodeType != 1) {
      if (lastChild.previousSibling) {
        lastChild = lastChild.previousSibling;
      } else {
        break;
      }
    }
    return lastChild;
  }

  function canContainText(node) {
    if (node.nodeType == 1) {
      return !['BR', 'IMG', 'INPUT', 'LABEL', 'DIV', 'SPAN', 'STRONG'].indexOf(node.nodeName) != -1;
    }
    return false;
  }

  function getEndOfContenteditable(element) {
    for (let child = getLastChild(element); child && canContainText(child); element = getLastChild(element)) {
      child = getLastChild(element);
    }
    return element;
  }

  function setEndOfContenteditable(element) { // https://stackoverflow.com/a/19588665
    const range = document.createRange();
    range.selectNodeContents(getEndOfContenteditable(element));
    range.collapse(false);
    const selection = window.getSelection();
    selection.removeAllRanges();
    selection.addRange(range);
  }

  window.addEventListener('DOMContentLoaded', (event) => {
    init()
      .then(() => {
        initConsole(document.getElementById('terminal'), document.getElementById('terminal-autocomplete'));
        //initNavigator(document.getElementById('navigator'));
      })
      .catch(error => console.error(error));
  });
  </script>
</head>
<body>
  <div id="terminal" tabindex="0" style="width: calc(100% - 20px); height: calc(50vh - 25px); max-height: calc(50vh - 25px); margin: 10px;">
  </div>
  <select multiple id="terminal-autocomplete"></select>
  <div style="display: none; width: calc(100% - 20px); height: calc(50vh - 25px); max-height: calc(50vh - 25px); margin: 10px; overflow-x: hidden; overflow-y: scroll;">
    <div id="display" style="width: 100%;"></div>
  </div>
  <div id="text-editor" style="display: none; width: calc(100% - 20px); height: calc(50vh - 25px); max-height: calc(50vh - 25px); margin: 10px;"></div>
</body>
</html>
